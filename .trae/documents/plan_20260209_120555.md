# 基于 Cookie 的用户识别系统实施方案

## 📋 需求分析
- 基于浏览器 cookie 做用户判断
- 不同浏览器之间不交换工作流
- 不同用户看到自己的工作流
- 不出现重复名称的工作流

## 🎯 实施方案

### 后端改造

1. **修改 Workflow 实体**
   - 添加 `browserId` 字段（用于标识不同浏览器/用户）
   - 添加唯一索引：防止同一 browserId 下重复名称

2. **修改 WorkflowService**
   - `create()`: 添加 browserId 参数并保存
   - `findAll()`: 按 browserId 过滤工作流
   - `findOne()`: 验证 browserId 匹配
   - `update()`: 验证 browserId 匹配
   - `remove()`: 验证 browserId 匹配

3. **修改 WorkflowController**
   - 启用 JwtAuthGuard（从 cookie 中提取 browserId）
   - 所有方法从请求中提取 browserId
   - 添加浏览器标识符验证

4. **创建/修改中间件**
   - 创建 Cookie 提取中间件
   - 自动生成 browserId（如果不存在）
   - 将 browserId 注入到请求对象

### 前端改造

1. **安装依赖**
   - 安装 `js-cookie` 库用于 cookie 管理

2. **创建 cookie 工具**
   - 获取/设置 browserId
   - 自动生成唯一标识符

3. **修改 API 工具**
   - 所有请求自动携带 browserId cookie
   - 从响应中接收 browserId（如果后端返回新的）

4. **修改路由守卫**
   - 确保每个请求都有有效的 browserId

5. **修改工作流服务**
   - 创建工作流时不需要额外参数（后端从 cookie 获取）
   - 显示的工作流自动过滤

### 数据库迁移
   - 为现有 workflows 表添加 browserId 列
   - 添加唯一索引：(browserId, name)

## 📁 需要创建/修改的文件

### 后端
- `backend/src/workflow/entities/workflow.entity.ts` - 添加 browserId 字段
- `backend/src/workflow/workflow.service.ts` - 添加 browserId 过滤逻辑
- `backend/src/workflow/workflow.controller.ts` - 启用认证并提取 browserId
- `backend/src/common/middleware/browser-id.middleware.ts` - 新建：cookie 处理中间件
- `backend/src/workflow/workflow.module.ts` - 注册中间件

### 前端
- `frontend/package.json` - 添加 js-cookie 依赖
- `frontend/src/utils/cookie.ts` - 新建：cookie 工具函数
- `frontend/src/utils/api.ts` - 自动携带 browserId
- `frontend/src/services/workflowService.ts` - 移除 userId 参数（后端从 cookie 获取）

## 🚀 预期效果
1. 首次访问时自动生成 browserId 并存储在 cookie
2. 每个浏览器看到自己的工作流列表
3. 同一浏览器内创建的工作流不会重复
4. 不同浏览器之间数据完全隔离
5. 无需登录页面，用户体验流畅