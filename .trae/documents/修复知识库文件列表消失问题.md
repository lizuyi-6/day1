## 问题描述

用户上传新文档后，之前已存在的文档从列表中消失。

## 根因分析

`getDocuments` 方法存在严重缺陷：

1. **查询限制的是 chunks 数量，不是文件数量**
   - 默认 `take: limit` 只取 20 条 chunks
   - 如果一个文件有多个 chunks，会占用多个查询名额
   - 导致某些文件完全不会出现在查询结果中

2. **先查询 chunks 再分组的方式有缺陷**
   ```typescript
   const [documents, total] = await this.knowledgeRepository.findAndCount({
     take: limit, // 限制的是 chunks 数量！
   });
   // 再按 fileName 分组...
   ```

**示例场景**：
- 文件 A：15 个 chunks
- 文件 B：10 个 chunks
- 文件 C：5 个 chunks

当 `limit=20` 时，查询可能只返回 A 的 15 个 chunks + B 的前 5 个 chunks，**文件 C 完全消失**。

## 解决方案

使用 TypeORM 的 QueryBuilder 重写 `getDocuments` 方法：

1. **使用子查询获取唯一的文件名列表**
   - `SELECT DISTINCT "fileName" FROM knowledge`
   - 支持分页（按文件名分页，不是按 chunks）

2. **为每个文件获取统计信息**
   - chunk 数量：`COUNT(*)`
   - 最新上传时间：`MAX("createdAt")`
   - 第一个 chunk 的 ID：用于前端标识

3. **保持接口兼容性**
   - 返回格式与之前一致：`{ items, total, page, limit, totalPages }`
   - 支持 `fileName` 过滤参数

## 具体实现

### 修改 `knowledge.service.ts`

```typescript
async getDocuments(page: number = 1, limit: number = 20, fileName?: string) {
  const skip = (page - 1) * limit;

  // 1. 获取唯一的文件名列表（带过滤）
  const distinctFilesQuery = this.knowledgeRepository
    .createQueryBuilder('k')
    .select('k.fileName', 'fileName')
    .addSelect('MAX(k.createdAt)', 'maxCreatedAt')
    .groupBy('k.fileName');

  if (fileName) {
    distinctFilesQuery.where('k.fileName LIKE :fileName', { fileName: `%${fileName}%` });
  }

  // 先获取总数
  const totalResult = await distinctFilesQuery.getCount();

  // 再获取分页后的文件名列表
  const fileList = await distinctFilesQuery
    .orderBy('maxCreatedAt', 'DESC')
    .skip(skip)
    .take(limit)
    .getRawMany();

  // 2. 为每个文件获取详细统计
  const items = await Promise.all(
    fileList.map(async (file) => {
      const stats = await this.knowledgeRepository
        .createQueryBuilder('k')
        .select('COUNT(*)', 'chunkCount')
        .addSelect('MIN(k.id)', 'firstChunkId')
        .addSelect('MAX(k.createdAt)', 'uploadedAt')
        .where('k.fileName = :fileName', { fileName: file.fileName })
        .getRawOne();

      return {
        fileName: file.fileName,
        chunkCount: parseInt(stats.chunkCount, 10),
        firstChunkId: stats.firstChunkId,
        uploadedAt: stats.uploadedAt,
      };
    })
  );

  return {
    items,
    total: totalResult,
    page,
    limit,
    totalPages: Math.ceil(totalResult / limit),
  };
}
```

### 保持前端代码不变

前端 `KnowledgeView.vue` 的 `loadDocuments` 方法不需要修改，因为后端返回的数据格式与之前完全一致。

## 验证步骤

1. 准备 3 个不同的文档文件
2. 先上传文件 A（假设产生 15 个 chunks）
3. 再上传文件 B（假设产生 10 个 chunks）
4. 再上传文件 C（假设产生 5 个 chunks）
5. 验证列表中是否同时显示 A、B、C 三个文件
6. 刷新页面，验证文件列表依然完整

## 预期结果

修复后，无论上传多少文件，也无论每个文件产生多少 chunks，文件列表都应该：
- 显示所有已上传的文件（在分页范围内）
- 不会因为上传新文件而导致旧文件消失
- 正确显示每个文件的 chunk 数量和上传时间